class Background { constructor(params) {    this.self_id = Background.id++;    this.params = new BackgroundParameters(params);    this.html = document.createElement("div");    this.setup();  }  setup() {    this.html.id = `bg:${this.self_id}`;    this.html.style.width = `${this.params.width}px`;    this.html.style.height = `${this.params.height}px`;    this.html.style.backgroundColor = this.params.color;    this.html.style.zIndex = "1";  }  renderIn(root) {    const parent = root || document.getElementById("root");    parent === null || parent === void 0      ? void 0      : parent.appendChild(this.html);    return this;  }}Background.id = 0;const DefaultBackgroundParameters = {  width: 1280,  height: 720,  color: "#000000",};class BackgroundParameters {  constructor(params) {    this.width = params.width || DefaultBackgroundParameters.width;    this.height = params.height || DefaultBackgroundParameters.height;    this.color = params.color || DefaultBackgroundParameters.color;  }}const DefaultAxesMapParameters = {  x_units: 4,  y_units: 4,  x_sub_units: 5,  y_sub_units: 5,  origin: [2, 2],  line_width: 1,  sub_line_width: 0.2,  color: "#ffffff",};class AxesMapParameters {  constructor(params) {    this.x_units = params.x_units || DefaultAxesMapParameters.x_units;    this.y_units = params.y_units || DefaultAxesMapParameters.y_units;    this.x_sub_units =      params.x_sub_units || DefaultAxesMapParameters.x_sub_units;    this.y_sub_units =      params.y_sub_units || DefaultAxesMapParameters.y_sub_units;    this.origin = params.origin || DefaultAxesMapParameters.origin;    this.line_width = params.line_width || DefaultAxesMapParameters.line_width;    this.sub_line_width =      params.sub_line_width || DefaultAxesMapParameters.sub_line_width;    this.color = params.color || DefaultAxesMapParameters.color;  }}class AxesMap {  constructor(params, background) {    this.self_id = AxesMap.id++;    this.params = new AxesMapParameters(params);    this.background = background;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `axes_map:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "2";    const ctx = this.html.getContext("2d");    ctx.strokeStyle = this.params.color;    this.createLines(ctx);    this.createSublines(ctx);  }  createLines(ctx) {    ctx.lineWidth = this.params.line_width;    let x = 0;    for (let i = 0; i < this.params.x_units - 1; i++) {      ctx.beginPath();      x += this.background.params.width / this.params.x_units;      ctx.moveTo(x - this.params.line_width / 2, 0);      ctx.lineTo(x - this.params.line_width / 2, this.background.params.height);      ctx.stroke();    }    let y = 0;    for (let i = 0; i < this.params.y_units - 1; i++) {      ctx.beginPath();      y += this.background.params.height / this.params.y_units;      ctx.moveTo(0, y - this.params.line_width / 2);      ctx.lineTo(this.background.params.width, y - this.params.line_width / 2);      ctx.stroke();    }  }  createSublines(ctx) {    ctx.lineWidth = this.params.sub_line_width;    let x = 0;    let x_sub_units = this.params.x_units * this.params.x_sub_units;    for (let i = 0; i < x_sub_units - 1; i++) {      ctx.beginPath();      x += this.background.params.width / x_sub_units;      ctx.moveTo(x - this.params.line_width / 2, 0);      ctx.lineTo(x - this.params.line_width / 2, this.background.params.height);      ctx.stroke();    }    let y = 0;    let y_sub_units = this.params.y_units * this.params.y_sub_units;    for (let i = 0; i < y_sub_units - 1; i++) {      ctx.beginPath();      y += this.background.params.height / y_sub_units;      ctx.moveTo(0, y - this.params.line_width / 2);      ctx.lineTo(this.background.params.width, y - this.params.line_width / 2);      ctx.stroke();    }  }  getOrigin() {    const origin = [0, 0];    origin[0] =      (this.background.params.width * this.params.origin[0]) /      this.params.x_units;    origin[1] =      (this.background.params.height * this.params.origin[1]) /      this.params.y_units;    return origin;  }  render() {    this.background.html.appendChild(this.html);    return this;  }}AxesMap.id = 0;const DefaultGraphParameters = {  name: "f",  parameter: "x",  expression: (x) => x,  domains: [[-2, 2]],  color: "#ff00ff",  line_width: 2,  step: 0.01,};class GraphParameters {  constructor(params) {    this.name = params.name || DefaultGraphParameters.name;    this.parameter = params.parameter || DefaultGraphParameters.parameter;    this.expression = params.expression || DefaultGraphParameters.expression;    this.domains = params.domains || DefaultGraphParameters.domains;    this.color = params.color || DefaultGraphParameters.color;    this.line_width = params.line_width || DefaultGraphParameters.line_width;    this.step = params.step || DefaultGraphParameters.step;  }}class Graph {  constructor(params, axes_map) {    this.self_id = Graph.id++;    this.params = new GraphParameters(params);    this.background = axes_map.background;    this.axes_map = axes_map;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `graph:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "4";    const ctx = this.html.getContext("2d");    this.draw(ctx);  }  draw(ctx) {    const origin = this.axes_map.getOrigin();    this.params.domains.forEach((domain) =>      this.drawGraphInDomain(origin, domain, ctx)    );  }  drawGraphInDomain(origin, domain, ctx) {    let pointes = Graph.getPointes(this, domain, origin, this.params.step);    ctx.strokeStyle = this.params.color;    ctx.lineWidth = this.params.line_width;    for (let i = 0; i < pointes.length - 1; i++) {      ctx.beginPath();      ctx.moveTo(pointes[i][0], pointes[i][1]);      ctx.lineTo(pointes[i + 1][0], pointes[i + 1][1]);      ctx.stroke();    }  }  static getPointes(graph, domain, origin, step) {    const pointes = [];    for (let i = domain[0]; i <= domain[1]; i += step)      pointes.push([...graph.getPoint(i, graph.params.expression(i), origin)]);    return pointes;  }  getPoint(x, y, origin) {    return [      (this.background.params.width / this.axes_map.params.x_units) * x +        origin[0],      -((this.background.params.height / this.axes_map.params.y_units) * y) +        origin[1],    ];  }  render() {    this.background.html.appendChild(this.html);    return this;  }}Graph.id = 0;const DefaultIntegralParameters = {  domain: [-2, 2],  step: 0.01,};class IntegralParameters {  constructor(params) {    this.domain = params.domain || DefaultIntegralParameters.domain;    this.step = params.step || DefaultIntegralParameters.step;  }}class Integral {  constructor(params, graph1, graph2) {    this.self_id = Integral.id++;    this.params = new IntegralParameters(params);    this.background = graph1.axes_map.background;    this.axes_map = graph1.axes_map;    this.graph1 = graph1;    this.graph2 = graph2;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `integral:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "3";    const ctx = this.html.getContext("2d");    this.integrate(ctx);  }  integrate(ctx) {    const pathes = this.getPathes();    ctx.fillStyle = "#ffffff";    ctx.globalAlpha = 0.4;    for (let i = 0; i < pathes.length - 1; i++) {      if (pathes[i + 1][1][1] > pathes[i + 1][0][1])        ctx.fillStyle = this.graph1.params.color;      else ctx.fillStyle = this.graph2.params.color;      ctx.beginPath();      ctx.moveTo(pathes[i][0][0], pathes[i][0][1]);      ctx.lineTo(pathes[i][1][0], pathes[i][1][1]);      ctx.lineTo(pathes[i + 1][1][0], pathes[i + 1][1][1]);      ctx.lineTo(pathes[i + 1][0][0], pathes[i + 1][0][1]);      ctx.fill();    }  }  getPathes() {    const pathes = [];    const origin = this.axes_map.getOrigin();    const graph1_points = Graph.getPointes(      this.graph1,      this.params.domain,      origin,      this.params.step    );    const graph2_points = Graph.getPointes(      this.graph2,      this.params.domain,      origin,      this.params.step    );    for (let i = 0; i < graph1_points.length - 1; i++) {      pathes.push([        graph1_points[i],        graph2_points[i],        graph1_points[i + 1],        graph2_points[i + 1],      ]);    }    return pathes;  }  render() {    this.background.html.appendChild(this.html);    return this;  }}Integral.id = 0;const DefaultLineParameters = {  a: 0,  b: 0,  domain: [-2, 2],  line_width: 1,  color: "#ffffff",};class LineParameters {  constructor(params) {    this.a = params.a || DefaultLineParameters.a;    this.b = params.b || DefaultLineParameters.b;    this.domain = params.domain || DefaultLineParameters.domain;    this.line_width = params.line_width || DefaultLineParameters.line_width;    this.color = params.color || DefaultLineParameters.color;  }}class Line {  constructor(params, axes_map) {    this.self_id = Line.id++;    this.params = new LineParameters(params);    this.background = axes_map.background;    this.axes_map = axes_map;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `line:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "5";    const ctx = this.html.getContext("2d");    this.draw(ctx);  }  draw(ctx) {    ctx.strokeStyle = this.params.color;    ctx.lineWidth = this.params.line_width;    const points = this.getPoints();    ctx.moveTo(points[0][0], points[0][1]);    ctx.lineTo(points[1][0], points[1][1]);    ctx.stroke();  }  getPoints() {    let a = this.params.a;    let b = this.params.b;    return Graph.getPointes(      new Graph({ expression: (x) => a * x + b }, this.axes_map),      this.params.domain,      this.axes_map.getOrigin(),      this.params.domain[1] - this.params.domain[0]    );  }  render() {    this.background.html.appendChild(this.html);    return this;  }}Line.id = 0;const DefaultPointParameters = {  position: [0, 0],  radius: 2,  color: "#ffffff",};class PointParameters {  constructor(params) {    this.position = params.position || DefaultPointParameters.position;    this.radius = params.radius || DefaultPointParameters.radius;    this.color = params.color || DefaultPointParameters.color;  }}class Point {  constructor(params, axes_map) {    this.self_id = Point.id++;    this.params = new PointParameters(params);    this.background = axes_map.background;    this.axes_map = axes_map;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `point:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "6";    const ctx = this.html.getContext("2d");    this.draw(ctx);  }  draw(ctx) {    let point_position = this.getPosition(      this.params.position[0],      this.params.position[1],      this.axes_map.getOrigin()    );    ctx.fillStyle = this.params.color;    ctx.beginPath();    ctx.arc(      point_position[0],      point_position[1],      this.params.radius,      0,      2 * Math.PI    );    ctx.fill();  }  getPosition(x, y, origin) {    return [      (this.background.params.width / this.axes_map.params.x_units) * x +        origin[0],      -((this.background.params.height / this.axes_map.params.y_units) * y) +        origin[1],    ];  }  render() {    this.background.html.appendChild(this.html);    return this;  }}Point.id = 0;const DefaultVectorParameters = {  from_to: [0, 0, 1, 1],  color: "#ffffff",  line_width: 2,  head_size: 2,};class VectorParameters {  constructor(params) {    this.from_to = params.from_to || DefaultVectorParameters.from_to;    this.color = params.color || DefaultVectorParameters.color;    this.line_width = params.line_width || DefaultVectorParameters.line_width;    this.head_size = params.head_size || DefaultVectorParameters.head_size;  }}class Vector {  constructor(params, axes_map) {    this.self_id = Vector.id++;    this.params = new VectorParameters(params);    this.background = axes_map.background;    this.axes_map = axes_map;    this.html = document.createElement("canvas");    this.setup();  }  setup() {    this.html.id = `vector:${this.self_id}`;    this.html.width = this.background.params.width;    this.html.height = this.background.params.height;    this.html.style.position = "absolute";    this.html.style.zIndex = "7";    const ctx = this.html.getContext("2d");    this.draw(ctx);  }  draw(ctx) {    const from_to = this.getFromTo();    ctx.strokeStyle = this.params.color;    ctx.lineWidth = this.params.line_width;    ctx.beginPath();    ctx.moveTo(from_to[0] - this.params.line_width / 2, from_to[1]);    ctx.lineTo(from_to[2] - this.params.line_width / 2, from_to[3]);    ctx.stroke();    this.drawHead(from_to, ctx);  }  drawHead(from_to, ctx) {    let points = this.getHeadPoints(from_to, ctx);    ctx.fillStyle = this.params.color;    ctx.beginPath();    ctx.moveTo(points[0], points[1]);    ctx.lineTo(points[2], points[3]);    ctx.lineTo(points[4], points[5]);    ctx.fill();  }  getHeadPoints(from_to, ctx) {    const first_point = [from_to[2] - this.params.line_width / 2, from_to[3]];    const slope = this.getSlope();    const alpha = Math.atan(slope) - Math.PI / 6;    const second_point = [0, 0];    const beta = (Math.PI * 2) / 3 - alpha;    const third_point = [0, 0];    if (this.params.from_to[2] - this.params.from_to[0] <= 0) {      second_point[0] =        first_point[0] + Math.cos(alpha) * this.params.head_size;      second_point[1] =        first_point[1] - Math.sin(alpha) * this.params.head_size;      third_point[0] = first_point[0] - Math.cos(beta) * this.params.head_size;      third_point[1] = first_point[1] - Math.sin(beta) * this.params.head_size;    } else {      second_point[0] =        first_point[0] - Math.cos(alpha) * this.params.head_size;      second_point[1] =        first_point[1] + Math.sin(alpha) * this.params.head_size;      third_point[0] = first_point[0] + Math.cos(beta) * this.params.head_size;      third_point[1] = first_point[1] + Math.sin(beta) * this.params.head_size;    }    return [...first_point, ...second_point, ...third_point];  }  getSlope() {    return (      (this.params.from_to[1] - this.params.from_to[3]) /      (this.params.from_to[0] - this.params.from_to[2])    );  }  getFromTo() {    const origin = this.axes_map.getOrigin();    return [      ...this.getPosition(        this.params.from_to[0],        this.params.from_to[1],        origin      ),      ...this.getPosition(        this.params.from_to[2],        this.params.from_to[3],        origin      ),    ];  }  getPosition(x, y, origin) {    return [      (this.background.params.width / this.axes_map.params.x_units) * x +        origin[0],      -((this.background.params.height / this.axes_map.params.y_units) * y) +        origin[1],    ];  }  render() {    this.background.html.appendChild(this.html);    return this;  }}Vector.id = 0;const DefaultNameParameters = {  text: "",  position: [0, 0],  font_size: 16,  color: "#ffffff",};class NameParameters {  constructor(params) {    this.text = params.text || DefaultNameParameters.text;    this.position = params.position || DefaultNameParameters.position;    this.font_size = params.font_size || DefaultNameParameters.font_size;    this.color = params.color || DefaultNameParameters.color;  }}class Name {  constructor(params, element, axes_map) {    this.axes_map = axes_map;    const ctx = element.html.getContext("2d");    ctx.font = `${params.font_size}px sans-serif`;    ctx.fillStyle = params.color;    ctx.textAlign = "center";    ctx.textBaseline = "middle";    const position = this.getPosition(params.position[0], params.position[1]);    ctx.fillText(params.text, position[0], position[1]);  }  getPosition(x, y) {    const origin = this.axes_map.getOrigin();    return [      (this.axes_map.background.params.width / this.axes_map.params.x_units) *        x +        origin[0],      -(        (this.axes_map.background.params.height /          this.axes_map.params.y_units) *        y      ) + origin[1],    ];  }}const Graphs = {  Background,  AxesMap,  Graph,  Integral,  Line,  Point,  Vector,  Name,};export default Graphs;